To get back to that natural, shaded look while keeping per‑tile control, split the problem into “better albedo” and “data‑driven elevation”:

Bring back a rich color/albedo map instead of flat hex fills. Either re‑export the old rendered map (e.g., map.php → map.png or your dynmap imagery) and load that as the texture on the globe, or generate a higher‑detail tile atlas (several px per tile with noise/patterns) before buildGlobeTextures writes the DataTexture. Keep using map.txt for alignment so buildings/roads still line up.
Make elevation explicit per tile. Add a height (or elevation) field to each entry in public/terrain-map.json (e.g., buildings > roads > plains > water=0) and update resolveHeight in src/textureBuilder.ts to prefer that numeric value over the current keyword guess. This lets you set player‑built structures to a specific displacement.
Derive lighting detail from the height map. Generate a normal map from the height data and feed it to MeshStandardMaterial (normalMap + normalScale) so you keep the sculpted shading even if geometry stays modest.
Increase geometric fidelity where needed: use a higher segments value (mapWidth ÷ 2–3), keep DISPLACEMENT_SCALE a bit higher, and stay power‑of‑two so wrapS can be RepeatWrapping.
Keep pole padding/wrap intact so the albedo and height maps stay seamless.
Natural next steps: 1) generate the high‑detail albedo map and hook it up in bootstrapGlobe, 2) enrich terrain-map.json with per‑tile heights and wire it into textureBuilder, 3) add on‑the‑fly normal map generation from the height buffer.